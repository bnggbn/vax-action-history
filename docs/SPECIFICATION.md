# VAX L0 Technical Specification

**Version:** 0.7
**Date:** 2026-01-07
**Status:** Reference Implementation Behavior
**Implementation:** vax-c, vax-go

---

## ⚠️ Document Status

This document describes the **precise technical behavior** of the VAX L0
reference implementations (vax-c and vax-go).

It is **not** a normative protocol specification.

For design rationale and philosophy, see [ARCHITECTURE.md](ARCHITECTURE.md).

---

## Table of Contents

1. Terminology
2. Data Formats
3. Canonicalization Rules (VAX-JCS)
4. gi Semantics
5. Counter Semantics
6. Action Submission Flow (L0 Core)
7. Verification Model
8. Submission Format
9. State Machine
10. Concurrency Model
11. Error Codes
12. Test Vectors
13. RFC 2119 Usage

---

## 1. Terminology

The following terms are used throughout this specification.

Unless explicitly marked as *Legacy* or *Optional*, definitions reflect
the **v0.7 L0 reference model**.

- **SO** — Semantic Object (schema-defined meaning)
- **SDTO** — Semantic Data Transfer Object (immutable)
- **SAE** — Semantic Action Encoding (canonical JSON)
- **SAI** — Semantic Action Identifier (32-byte action hash)
- **gi** — SDK-internal, single-use entropy (32 bytes)
- **Actor** — `(user_id, device_id)` tuple
- **Counter** — Actor-scoped sequencing metadata (L1 signal)
- **prevSAI** — Previous action’s SAI (32 bytes)

### Legacy Terms (Historical)

The following terms appear in earlier designs and are retained for
historical reference only:

- **K_chain** — Session secret used in early gi derivation models
- **gi_n** — PRF-derived entropy bound to counter (legacy)

These are **not required** for L0 correctness in v0.7.

---

## 2. Data Formats

### 2.1 SAE (Semantic Action Encoding)

SAE is the canonical JSON representation of an action.

**Format Requirements:**
- Encoding: UTF-8
- Whitespace: None
- Key ordering: Lexicographic (byte-order)
- Numbers: No scientific notation
- Unicode: NFC normalization required
- Non-ASCII: Escaped as UTF-16 code units (`\uXXXX`)

---

### 2.2 SAI (Semantic Action Identifier)

SAI is a 32-byte hash computed as:

```
SAI = SHA256(
"VAX-SAI" ||
prevSAI ||
SHA256(SAE) ||
gi
)
```

**Properties:**
- `prevSAI` provides chain continuity
- `gi` provides unpredictability
- Backend does not derive or interpret `gi`

**Genesis SAI:**

```
SAI_0 = SHA256(
"VAX-GENESIS" ||
actor_id ||
genesis_salt
)
```

---

## 3. gi Semantics (v0.7)

`gi` is an SDK-internal, single-use entropy value.

**Properties:**
- Generated by the SDK
- Used exactly once
- Not persisted
- Not transmitted separately
- Not interpreted or derived by the backend

**Purpose:**
- Prevents precomputation of future SAI values
- Ensures SAI unpredictability
- Does not encode order or identity

> The exact entropy generation method is not normative at L0.

### Legacy Note

Earlier designs derived `gi` via HMAC over a session secret and counter.
This coupling is **deprecated** and retained only for historical reference.

---

## 4. Counter Semantics

Counter is **not a correctness primitive**.

**Role:**
- Observability
- Debugging
- Anomaly detection (L1)

**Properties:**
- Actor-scoped
- Monotonic under normal operation
- Not included in hash computation
- Not required for L0 acceptance

**L0 Rule:**
> Counter values MUST NOT affect action validity.

Strict `+1` enforcement is **historical**, not required.

---

## 5. Action Submission Flow (L0 Core)
```
Raw Input
↓
SO Factory (normalize + validate)
↓
SDTO (immutable)
↓
SAE (canonical encoding)
↓
prevSAI
↓
gi = random SDK-internal entropy
↓
SAI = HASH(prevSAI || SAE || gi)
↓
Action Envelope
↓
Backend: VERIFY prevSAI continuity
↓
COMMIT or REJECT
```

**Backend Constraints:**
- MUST NOT modify semantics
- MUST NOT derive `gi`
- MUST NOT infer client state
- MUST only verify predecessor linkage

---

## 6. Verification Model

### 6.1 L0 Verification (Required)

An action is accepted if and only if:

incoming.prevSAI == backend.lastSAI


No other condition is required for L0 correctness.

### 6.2 L1 / Optional Checks

The following MAY be implemented as observability or policy signals:

- Counter jumps or gaps
- Rate anomalies
- Duplicate SAI detection
- Signature verification

Failures in these checks MUST NOT alter L0 chain validity.

---

## 7. Verification Algorithm (Reference)

### L0-Minimal Verifier
``` python
def verify_l0(prev_sai, last_sai):
    return prev_sai == last_sai
```
---

Legacy / Full Verification Mode (Optional)

Earlier implementations performed:

- Counter enforcement
- gi derivation
- Full SAI recomputation

These steps are not required for L0 correctness and are considered
legacy or L1 behavior.

## 8. Design Invariant (Normative)

Backend verification depends solely on predecessor continuity.
Order is established by commit history, not client-side sequencing.

Missing predecessors render actions unverifiable, not invalid.

---
## 9. Verification

### 9.1 L0 Verification Rule (Normative)

At L0, an action is considered valid if and only if it correctly
references the backend’s current committed predecessor.

incoming.prevSAI == backend.lastSAI


No other condition is required for L0 correctness.

In particular, the backend:
- MUST NOT derive `gi`
- MUST NOT recompute `SAI`
- MUST NOT enforce counter sequencing
- MUST NOT infer client-side state

---

### 9.2 Verification Pseudocode (L0-Minimal)

```python
def verify_and_commit(prev_sai: bytes, sae: str, sai: bytes) -> bool:
    actor = load_actor_state()

    # Verify predecessor continuity
    if prev_sai != actor.last_sai:
        return False

    # Verify canonicalization (semantic layer)
    if not is_canonical(sae):
        return False

    # Commit atomically
    with transaction():
        store_action(sai, sae)
        actor.last_sai = sai
        save_actor(actor)

    return True
```
---
### 9.3 Legacy / Full Verification Mode (Optional)

Earlier reference implementations performed additional checks:

- Strict +1 counter enforcement
- gi derivation from a session secret
- Full SAI recomputation and comparison

These steps are not required for L0 correctness and are considered
legacy or L1 behavior.

Implementations MAY include them for observability or policy purposes,
but failures MUST NOT alter L0 chain validity.

---

10. State Machine
10.1 SDK State Transitions
[DISCONNECTED]
    |
    | connect()
    ↓
[CONNECTED]
    |
    | sync()
    ↓
[SYNCED]
    |
    | propose(action)
    ↓
[PROPOSING]
    |
    | ← ACK
    ↓
[COMMITTED] → back to SYNCED
    |
    | ← NAK
    ↓
[REJECTED] → resync → SYNCED
    |
    | network error
    ↓
[DISCONNECTED]

10.2 State Descriptions

DISCONNECTED
- No active session
- Must establish connection before submitting actions

CONNECTED
- Session context established
- Must synchronize state before proposing actions

SYNCED
- prevSAI synchronized with backend
- Ready to propose actions

PROPOSING
- Action submitted
- Awaiting backend response
- Local state not yet advanced

COMMITTED
- Backend ACK received
- Local prevSAI updated
- Transition back to SYNCED

REJECTED
- Backend NAK received
- Local state may be stale
- MUST resynchronize before retrying

---
# 11. Concurrency Model
## 11.1 Single Writer Principle

One Actor = One serialized history.

At any given time, only one SDK instance SHOULD actively write
actions for a given Actor.

---

11.2 Backend Locking

Backends SHOULD implement per-Actor locking during commit:

```python
def commit_action(actor_id: str, action: Action):
    with actor_lock(actor_id):
        # Verify prevSAI
        # Commit atomically
        pass
```

This prevents:

- Race conditions
- Double-submission
- History divergence

---

### 11.3 Multi-Device Scenarios

If multiple devices share the same user:

Option 1: Separate Actors
```
device_a: Actor = "user123:device_a"
device_b: Actor = "user123:device_b"
```

Each device maintains an independent history.

Option 2: Coordinated Write
```cpp
// Only one device writes at a time
// Other devices remain read-only or request coordination
```

L0 does not define coordination mechanisms (out of scope).

---

## 12. Error Codes

Error codes are divided by **layer responsibility**.
Only L0 errors affect chain validity.

---

### 12.1 L0 Errors (Integrity Layer)

These errors indicate a violation of **hash-chain continuity** or
canonical representation.
They MUST cause the action to be rejected at L0.

| Code | Description |
|------|-------------|
| `ERR_INVALID_PREV_SAI` | `prevSAI` does not match the last committed SAI |
| `ERR_INVALID_CANONICALIZATION` | SAE violates VAX-JCS canonical rules |
| `ERR_DUPLICATE_SAI` | SAI already exists (replay or double-submit) |
| `ERR_INVALID_SESSION` | Session not found or expired |

---

### 12.2 L1 / Optional Errors (Observability & Policy)

These errors represent **behavioral anomalies or policy violations**.
They MUST NOT affect L0 chain correctness.

| Code | Description |
|------|-------------|
| `ERR_INVALID_COUNTER` | Counter is unexpected or non-monotonic |
| `ERR_COUNTER_OVERFLOW` | Counter exceeded implementation limit |
| `ERR_INVALID_SIGNATURE` | Optional signature verification failed |
| `ERR_RATE_LIMITED` | Submission rate exceeded policy |
| `ERR_POLICY_VIOLATION` | Domain or application-level policy violation |

Actions rejected for L1 reasons MAY still be structurally valid
and verifiable at L0.

---

### 12.3 Server Errors (5xx)

These errors indicate backend failures unrelated to action correctness.

| Code | Description |
|------|-------------|
| `ERR_STORAGE_FAILURE` | Database or storage subsystem failure |
| `ERR_INTERNAL` | Unspecified internal server error |

---

### 12.4 Error Response Format

```json
{
  "status": "rejected",
  "error": "ERR_INVALID_PREV_SAI",
  "detail": "prevSAI does not match last committed SAI",
  "expected": "<last_sai_hex>",
  "received": "<incoming_prev_sai_hex>"
}
```
---

## 13. Test Vectors
### 13.1 Canonicalization Test

Input:
```json
{
  "name": "Alice",
  "age": 30,
  "city": "Tokyo"
}
```

Expected Output:
```json
{"age":30,"city":"Tokyo","name":"Alice"}
```

---

### 13.2 Genesis SAI Test Vector

Input:

actor_id: "user123:device456"

genesis_salt (hex): a1a2a3a4a5a6a7a8a9aaabacadaeafb0

Expected Genesis SAI (hex):

afc50728cd79e805a8ae06875a1ddf78ca11b0d56ec300b160fb71f50ce658c3

---

### 13.3 SAI Chain Test (Conceptual)

Genesis:

SAI_0 = HASH("VAX-GENESIS" || actor_id || genesis_salt)


Action 1:
``` ini
prevSAI = SAI_0
SAE = {"action":"deposit","amount":100}
gi = random entropy
SAI_1 = HASH(prevSAI || SAE || gi)
```

Action 2:
```ini
prevSAI = SAI_1
SAE = {"action":"withdraw","amount":50}
gi = random entropy
SAI_2 = HASH(prevSAI || SAE || gi)
```
---
## Revision History

| Version | Date | Changes |
|---------|------|---------|
| 0.7 | 2026-01-07 | gi spec |
| 0.6 | 2025-12-08 | Split from combined doc; added test vectors |
| 0.4 | 2025-11-24 | Added distributed semantics |
| 0.3 | 2025-11-08 | Initial version |

---

**End of Technical Specification**
